# example-react-flow 技术笔记

> 本文档用于记录 example-react-flow 子项目的关键技术实现、设计思路、踩坑与优化建议等。
> 如果你只是在维护本文档而没有负责其他任务，那么请不要为将要完成的任务设想解决方案。应该由负责这个任务的AI来专门思考解决方案。
> 信息依赖指引：
> - 请阅读 working-notes 文件夹中的其他文档，以便了解整个项目的背景和目标。
> - 请阅读同级的"目标描述与任务进度.md"，关于项目的目标/需求的详细描述以该文档为准。

## 目录

1. 组件设计与实现要点
2. 关键交互技术方案
   - 2.1 文本模式下拖动拉框创建节点
   - 2.2 节点的创建、编辑与聚焦
   - 2.3 连接模式新方案
   - 2.4 工具栏模式的全局管理与自动切换
   - 2.5 鼠标样式的多模式细节优化
   - 2.6 节点编辑区阻止拖动的最佳实践
   - 2.7 代码节点的contentEditable编辑实现
   - 2.8 节点宽度调整功能
   - 2.9 全局键盘事件监听与视野控制
   - 2.10 画布状态的序列化、持久化与恢复
3. 重要第三方库用法
4. 性能优化与可扩展性
5. 未来可优化点

---

## 1. 组件设计与实现要点

- 画布主组件：Canvas
- 工具栏：Toolbar
- 自定义节点：TextNode
- 自定义边：CustomEdge
- 节点与边的类型注册：在 Canvas 组件中通过 nodeTypes 和 edgeTypes 注册自定义节点和边，便于扩展。
- 节点/边的全局状态管理：主画布用 useNodesState/useEdgesState，但也有基于 Zustand 的 nodeStore 和 edgeStore，可用于更复杂的全局状态同步。

## 2. 关键交互技术方案

### 2.1 文本模式下拖动拉框创建节点

**需求简述：**
- 在"文本"模式下，用户可在画布空白处按下鼠标并拖动，拉出一个矩形区域，松开后在该区域创建一个文本/代码节点。
- 节点宽度为拉框宽度，高度始终为1行（即最小高度），并自动进入编辑态。
- 节点的 border 为 1px，padding 为 8px，代码区（contentEditable 编辑区）占据 border+padding 之内的全部空间。

**技术实现要点：**
1. 仅在 activeTool 为 'text' 时，监听画布的 onMouseDown、onMouseMove、onMouseUp。
2. 鼠标按下时记录起点，拖动时渲染一个半透明预览矩形，松开时计算拉框的宽度，创建节点，节点高度始终为1行。
3. 创建节点时，将宽度（和最小高度）通过 data 传递给 TextNode。
4. 代码节点组件支持 data 里传入 width，渲染时设置 style={{ width }}。
5. 预览矩形需在 Canvas 上层渲染，样式半透明、边框虚线。
6. 节点宽度需减去 border+padding，保证视觉与实际一致。

**注意事项：**
- 需兼容最小宽度（如 150px）和最小高度（如 40px）。

### 2.2 节点的创建、编辑与聚焦

- 支持多种节点创建方式：选择模式下双击空白处、文本模式下单击或拉框、应用初始化自动放置等。
- 通过 initialEditing 标记区分"用户手动新建代码节点"（需自动进入编辑态）和"应用初始化放置代码节点"（不进入编辑态）。
- 自动聚焦实现细节：不能直接设置 isEditing 为 true，否则 contentEditable 编辑区的 autofocus 不生效。正确做法是初始为 false，通过 useEffect 监听 initialEditing，再切换 isEditing 为 true，从而确保自动聚焦生效。

### 2.3 连接模式新方案

**背景与目标：**
- 参考 Excalidraw 的无锚点连接体验，优化连接模式的交互。
- 用户在"连接模式"下，无需精确点击锚点，直接在节点本体上按下鼠标并拖动到目标节点即可完成连接，提升连接效率和自然性。

**实现要点：**
1. **连接模式的切换与状态管理：**
   - 通过全局 activeTool 状态（Zustand store）切换到"connect"模式。
   - 工具栏按钮可切换当前模式，连接模式下鼠标样式和节点交互均有区分。

2. **节点本体即为连接区域：**
   - 每个代码节点始终渲染连接把手（handle），但仅在连接模式下显示（通过 hide-handle 类控制）。
   - 连接模式下，整个节点主体都可作为连接的起点和终点，用户体验为"无锚点"。
   - 通过 isConnectable 属性和 activeTool 状态，动态控制连接把手的可用性和可见性。

3. **连接线与自定义边：**
   - 连接线和最终的边均使用自定义实现（FloatingEdge），采用直线连接，并带有箭头。
   - 连接点的计算采用节点几何中心到中心的最短路径，并通过 getNodeIntersection 算法确保连接线自然地从节点边缘出发。
   - 连接线样式（如虚线、动画、箭头）在 CSS 和 SVG marker 中统一定义，风格极简、未来感。

4. **连接流程：**
   - 用户在连接模式下，点击某代码节点主体并拖动到另一代码节点主体，松开鼠标即创建连接。
   - 连接过程中有视觉反馈（如连接线预览）。
   - 连接完成后自动切回选择模式（如有实现）。

5. **与 React Flow 的集成：**
   - 通过 onConnect 回调处理连接事件，自动添加自定义类型的边。
   - connectionLineComponent 指定自定义连接线组件，保证连接预览与最终边一致。

**优势与体验提升：**
- 用户无需精确操作锚点，连接更自然、流畅。
- 视觉上锚点被"隐形"，界面更简洁。
- 连接线始终以最短路径连接节点边缘，避免穿透节点内容，提升美观性和可读性。
- 方案为后续实现更智能的连接点和高级交互（如多类型节点、动态锚点）打下基础。

### 2.4 工具栏模式的全局管理与自动切换

- 工具栏的当前模式（activeTool）通过 zustand 全局 store（useToolStore）管理，所有需要感知当前模式的组件均可直接读取。
- 典型交互：
  - 文本模式下，单击画布空白处或代码节点主体，完成节点创建/编辑后，自动切回选择模式。
  - 连接模式下，完成一次连接后（如连接创建成功或取消），也会切回选择模式（如有实现）。
- 这样保证了交互的直觉性，用户无需手动频繁切换模式，体验更贴近 Excalidraw 等主流画布产品。

### 2.5 鼠标样式的多模式细节优化

**需求：**
- 选择模式（select）：
  - 画布空白区为抓手（grab，React Flow 默认即可）。
  - 代码节点上方为 pointer（手指点击）。
- 文本模式（text）：
  - 画布空白区和代码节点上方都为文本光标（text），暗示可输入和编辑。

**实现要点：**
- 由于 React Flow 默认会在 `.react-flow__pane` 上强制设置 `cursor: grab`，所以不能仅靠外层 div 的 style 控制空白区的 cursor。
- 解决方法：
  1. 在 Canvas 组件最外层 div 上根据 activeTool 动态添加 `text-mode` class。
  2. 在 `Canvas/styles.css` 中增加如下样式：
     ```css
     .text-mode .react-flow__pane {
       cursor: text !important;
     }
     ```
  3. 代码节点主体（TextNode 组件）最外层 div 通过 style 动态切换 cursor：
     - select 模式下为 pointer
     - text 模式下为 text
- 这样即可实现多模式下鼠标样式的细致区分，且不会被 React Flow 默认样式覆盖。

**踩坑记录：**
- 仅在 Canvas 外层 div 上设置 cursor 无法覆盖 React Flow 画布空白区的 grab 样式，必须用更高优先级的 class 选择器和 `!important`。
- 代码节点主体的 cursor 建议直接用 style 动态切换，避免全局样式污染。

### 2.6 节点编辑区阻止拖动的最佳实践

- 在 React Flow 中，如果希望节点的某个区域（如编辑态下的 contentEditable 编辑区）不触发节点拖动，只需给该区域元素加上 `nodrag` class。
- 这样可以让用户在编辑区内自由选中、复制、编辑文本，而不会误触节点拖动或画布 pan。
- 这一点在 React Flow 的官方文档中很隐秘，藏在一个例子中，不仔细观察很难发现。
- 另外还有 `nowheel` class，可以阻止画布滚轮缩放。

### 2.7 代码节点的contentEditable编辑实现

**背景与动机**：
- 采用contentEditable 编辑区可以获得更高的自由度，实现更接近代码编辑器的体验
- 便于实现行号、语法高亮等高级功能
- 为后续扩展更丰富的代码编辑功能奠定基础

**实现关键点**：
1. 基本实现：
   - 使用带有contentEditable="true"属性的 contentEditable 编辑区作为代码编辑区
   - 处理编辑区内容的获取与设置
2. 事件处理：
   - 使用onInput事件监听内容变化
   - 处理键盘事件，如Tab键、Enter键、Shift+Enter组合键等
   - 处理粘贴事件，确保代码格式一致性
3. 光标与选择区域：
   - 使用Selection和Range API手动处理光标位置
   - 实现自动聚焦和保持编辑状态
4. 占位符效果：
   - 由于 contentEditable 编辑区没有原生 placeholder 属性，需要自行实现类似效果，如通过动态插入/移除默认文本
5. 样式一致性：
   - 确保视觉效果与代码编辑器一致
   - 保持等宽字体、行高、换行等代码显示特性

**补充说明**：
- 已实现点击进入编辑时光标定位到点击处，相关算法已抽象为 placeCaretAtPoint 工具函数。
- 为防止 React diff 导致的内容残影，编辑态和显示态的根节点加上不同的 key。

### 2.8 节点宽度调整功能

**背景与动机**：
- 固定宽度的节点无法满足不同长度代码的展示需求
- 用户需要根据代码长度和个人偏好调整节点宽度
- React Flow提供了NodeResizer组件可以实现拖动调整大小功能

**实现关键点**：
1. **基本设置**：
   - 引入宽度调整控制点（NodeResizeControl）组件，分别绝对定位于代码节点左右两侧，宽度约8px，高度100%，完全透明且无边框、无圆角，仅在节点被选中时可用。
   - 配置最小宽度约束（200px），无最大宽度限制，支持无限制扩展
   - 设置只允许水平方向调整大小（resizeDirection='horizontal'）
2. **交互体验**：
   - 用户可通过拖动任意一侧调整节点宽度，符合极简未来感设计要求。
   - 调整宽度调整控制点的样式，与整体设计风格一致
   - 根据选中状态控制宽度调整控制点的可见性
3. **状态管理**：
   - 节点大小变化通过onResize回调实时更新到节点数据中的width属性
   - 宽度信息持久化保存，确保刷新后保持
   - 编辑模式和显示模式下宽度完全一致
4. **边缘处理**：
   - 与连接把手（handle）的协调，确保不影响连接功能
   - 与代码节点编辑状态的协调，避免冲突
5. **React Flow样式覆盖**：
   - 添加CSS覆盖规则，移除React Flow默认的节点宽度限制
   - 使用`!important`确保自定义样式优先级足够高
6. **技术要点**：
   - NodeResizeControl需加上resizeDirection='horizontal'属性，否则react-flow对节点大小的测量会不准确，影响自定义边的计算。
   - 节点高度目前由内容自适应，如需支持高度拖拽需在节点数据结构中显式存储height，并在渲染和NodeResizeControl中传递。
   - 透明连接把手在未选中时也可拖动。

**最新实现状态（✅ 已完成）**：
- ✅ 支持200px-无限制的宽度调整范围
- ✅ 编辑模式和显示模式宽度完全一致
- ✅ 宽度设置持久化保存和恢复
- ✅ 极简透明的拖拽控件设计
- ✅ 与React Flow默认样式的兼容性处理

### 2.9 全局键盘事件监听与视野控制

**需求简述：**
- 监听全局键盘事件，实现 wasd 控制画布平移（pan），V/T/C 快捷键切换模式。
- 保证与输入框等编辑区的键盘事件不冲突（如编辑代码时不触发 pan 或模式切换）。

**技术实现要点：**
1. 在 Canvas 组件或全局入口处监听 keydown 事件。
2. 判断事件目标，避免在 contentEditable/textarea/input 等编辑区触发快捷键。
3. wasd 控制 pan：调用 React Flow 的 `setViewport` 或 `panBy` 方法，支持按住连续移动。
4. V/T/C 切换模式：调用 zustand 的 `setActiveTool`，并触发视觉反馈（如高亮工具栏按钮）。
5. 需考虑快捷键与系统/浏览器默认行为的冲突，必要时阻止默认事件。
6. 相关状态和回调建议集中管理，便于维护和扩展。

**注意事项：**
- 编辑区聚焦时应禁用快捷键，防止影响正常输入。
- 需兼容不同操作系统的键盘布局。

- 已将WASD惯性/缓动式移动逻辑封装为 useInertialPan hook，主组件只需调用即可，便于维护和复用。
- V/T/C 工具切换快捷键监听单独在 Canvas 组件中实现，避免与方向键冲突，职责清晰。

### 2.10 画布状态的序列化、持久化与恢复

**需求简述：**
- 能够将当前画布上的所有节点、边、节点内容、节点尺寸和位置等信息序列化为结构化数据（如 JSON），支持导出和导入。
- 用户操作后自动保存到本地（如 localStorage），下次打开时能恢复画布状态。
- 提供导入/导出按钮，便于用户手动操作。

**设计思路与技术建议：**
1. **数据结构设计**：
   - 需保存节点（id、type、data、position、width、height等）、边（id、source、target、type、data等）等全部必要信息。
   - 可参考 React Flow 的内部节点/边结构，或自定义扩展。
2. **序列化与反序列化**：
   - 导出时将节点、边等状态序列化为 JSON。
   - 导入时解析 JSON，恢复到画布。
   - 注意 data 字段的深拷贝，避免引用问题。
3. **自动保存与恢复**：
   - 监听节点/边的增删改、拖拽、尺寸调整等操作，自动保存到 localStorage。
   - 页面加载时检测 localStorage，自动恢复。
   - 可考虑 debounce 优化保存频率。
4. **导入/导出按钮**：
   - 在工具栏或菜单中提供导入/导出按钮。
   - 导出时下载 JSON 文件，导入时选择文件并解析。
5. **版本兼容与数据校验**：
   - 数据结构可加 version 字段，便于未来升级兼容。
   - 导入时校验数据合法性，异常时给出提示。
6. **异常处理与边界情况**：
   - localStorage 空间不足时给出提示。
   - 数据损坏或不兼容时可回退到初始状态。

**注意事项与踩坑点：**
- 需兼容未来节点/边类型扩展。
- 需考虑 localStorage 空间限制，必要时可做数据压缩。
- 需处理循环引用、数据丢失等问题。
- 需兼容已有节点/边的创建、编辑、拖拽、尺寸调整等操作，确保状态同步。
- 可考虑为导入/导出增加进度提示或错误提示。

**实现补充：**
- 已实现自动保存与自动恢复，采用 localStorage，数据结构带版本号。
- 导入/导出通过 Toolbar 按钮触发，支持 JSON 文件格式。
- 持久化逻辑已独立封装在 utils/persistence.ts，便于未来扩展。

> 后续AI实现时请优先参考本节内容，并结合实际代码结构灵活调整。

## 3. 重要第三方库用法

- React Flow：节点、边、画布交互的核心库，支持自定义节点/边、拖拽、连接、缩放等。
- Zustand：虽然主流程用 React Flow 的 hooks 管理节点/边，但也有全局 store 设计，便于后续复杂状态同步。
- CSS 方案：自定义节点、边、工具栏等均有独立样式文件，部分样式通过类名动态切换（如连接模式）。

## 4. 性能优化与可扩展性

- 节点/边的唯一 id 生成：通过工具函数生成，避免重复。
- 节点/边的类型扩展：通过集中注册 nodeTypes/edgeTypes，便于后续扩展更多类型。
- 全局状态与局部状态的平衡：目前主流程用 React Flow 的 hooks，复杂场景可切换到 Zustand。

## 5. 未来可优化点

- 节点内容的自动保存与撤销/重做。
- 支持节点/边的批量操作与多选。
- 画布缩放、平移的更多自定义交互。
- 节点内容的语法高亮与代码补全。
- 支持节点高度自适应内容
- ~~支持节点宽度拖拽调整~~ (正在实现中)

> 本文件持续完善，欢迎补充。

## 项目结构- **前端**: React + TypeScript + Vite + React Flow- **后端**: Julia HTTP服务器 (基于HTTP.jl)- **核心功能**: 可视化编程节点 + Julia代码执行 + 变量控件系统- **状态管理**: Zustand + React Flow hooks- **样式**: TailwindCSS + 自定义CSS- **构建工具**: Vite + pnpm### 前端架构- **Canvas**: 主画布组件，集成React Flow- **TextNode**: 自定义节点组件，支持代码编辑和控件显示- **CustomEdge**: 自定义边组件，实现无锚点连接- **Toolbar**: 工具栏组件，支持模式切换- **VariableControls**: 变量控件组件，支持多种控件类型### 后端架构- **server.jl**: HTTP服务器主文件- **evaluator.jl**: 代码执行引擎- **variable_parser.jl**: 变量解析器，处理@input/@output标记## 当前技术栈详情### 已采用的技术栈- **React 19.0.0**: 前端核心框架- **@xyflow/react 12.6.0**: 画布和节点系统- **TypeScript**: 类型安全的开发语言- **Vite 6.2.0**: 现代构建工具- **TailwindCSS 4.1.5**: 原子化CSS框架- **Zustand 5.0.3**: 轻量级状态管理- **Julia + HTTP.jl**: 后端API服务器- **JSON3.jl**: JSON处理库### 项目依赖关系- 前端与后端通过HTTP API通信- React Flow提供画布基础能力- Zustand管理全局状态（工具栏模式、连接状态等）- Julia后端处理代码解析和执行## 最近修复的问题

### 2024-01-XX 编辑模式显示问题和底部异常显示 🔧

**问题描述:**
1. 编辑任何控件时，output区域和控件区域仍然显示，导致截图错误
2. 底部出现两个不明来源的条显示"output: 0"和"slidebar: 0"
3. 日志区域位置不正确，应该在输出和控件之间

**已修复问题:**
1. ✅ **编辑模式显示控制**: 添加`!isEditing`条件到所有需要在编辑时隐藏的区域
2. ✅ **日志区域位置**: 将日志区移动到输出和控件之间，符合用户期望
3. ✅ **分割线显示**: 将文字分割线改为视觉分割线，移除"log---------------"文字
4. ✅ **调试信息清理**: 移除顶部的编辑状态调试信息

**底部异常显示问题诊断:**
- 检查了所有组件代码，未发现意外的调试显示
- 编译无错误，代码结构正常
- 可能原因：
  1. React开发工具状态显示
  2. 浏览器扩展干扰
  3. 某种全局状态或调试信息
  
**建议解决方案:**
1. 关闭浏览器开发工具
2. 禁用浏览器扩展
3. 尝试无痕模式打开
4. 清除浏览器缓存
5. 重启开发服务器

**代码修改:**
- `TextNode/index.tsx`: 添加编辑模式条件判断，调整渲染顺序
- `TextNode/styles.css`: 移除log-header相关样式

### 2024-01-XX 节点卡片宽度自动扩展功能 ✅

**需求背景:**
- 用户反馈节点卡片宽度固定，无法适应不同长度的代码内容
- 长代码会被截断或超出卡片边界，影响编辑和阅读体验
- 需要实现真正的内容驱动宽度扩展机制

**技术挑战:**
1. React Flow默认节点有宽度限制
2. CSS的fit-content和max-content在某些情况下无法正确工作
3. 编辑模式和显示模式的宽度计算逻辑不同
4. 绝对定位的语法高亮层导致宽度计算错误

**实现方案:**
1. **CSS基础设置:**
   ```css
   .text-node {
     display: flex;
     flex-direction: column;
     width: fit-content;
     min-width: 300px;
     max-width: none; /* 移除最大宽度限制 */
   }
   ```

2. **JavaScript动态宽度计算:**
   ```javascript
   // 使用临时DOM元素测量文本实际宽度
   const adjustEditorSize = useCallback(() => {
     const tempElement = document.createElement('pre');
     tempElement.style.fontFamily = 'JetBrains Mono, monospace';
     tempElement.style.fontSize = '14px';
     tempElement.style.whiteSpace = 'pre';
     tempElement.style.position = 'absolute';
     tempElement.style.visibility = 'hidden';
     tempElement.textContent = text;
     
     document.body.appendChild(tempElement);
     const contentWidth = tempElement.offsetWidth;
     document.body.removeChild(tempElement);
     
     const minNodeWidth = Math.max(contentWidth + 60, 300);
     nodeContainer.style.width = `${minNodeWidth}px`;
   }, [text]);
   ```

3. **编辑模式和显示模式分别处理:**
   - `adjustEditorSize`: 编辑模式下的宽度调整
   - `adjustDisplayWidth`: 显示模式下的宽度调整
   - 两个函数都使用相同的测量逻辑，确保一致性

4. **语法高亮容器优化:**
   ```css
   .syntax-highlight-display, .text-node-editor {
     position: absolute;
     top: 0;
     left: 0;
     right: 0; /* 使用right: 0而非width: 100% */
     white-space: pre; /* 保持代码格式 */
     overflow: visible; /* 允许溢出 */
   }
   ```

**关键技术点:**
1. **临时DOM元素测量法**: 创建与实际渲染环境相同的临时元素来精确测量文本宽度
2. **React样式覆盖**: 通过JavaScript直接设置style属性，优先级高于CSS
3. **宽度计算公式**: `contentWidth + 60px`（60px包含padding、margin等）
4. **实时调整**: 在文本变化、编辑状态变化时自动调用宽度调整函数

**解决的问题:**
- ✅ 文本超出卡片边界问题
- ✅ 编辑器被截断导致无法编辑长代码问题
- ✅ 编辑模式和显示模式宽度不一致问题
- ✅ CSS flex容器宽度计算错误问题

**性能优化:**
- 使用临时DOM元素而非hidden div，避免影响布局
- 测量完成后立即移除临时元素
- 使用useCallback缓存函数，避免重复创建

**边界情况处理:**
- 最小宽度300px保证界面美观
- 空文本时使用占位符进行宽度计算
- 异常情况下降级到默认宽度

**后续改进方向:**
- 考虑使用Canvas API测量文本宽度，提高性能
- 增加防抖机制，避免频繁调整
- 支持用户手动设置最大宽度限制 